apply:
        push rbp
        mov rbp, rsp
        push SOB_NIL_ADDRESS ;; push magicarg
        xor r8, r8 ;; we will use to count number of args in list
        mov r9 , PARAM_COUNT
        dec r9
        mov rsi, PVAR(r9) ;; last argument is list -> rsi
        .get_list_params:
         mov dl, byte [rsi]
         cmp dl, T_NIL
         je .pre_rearange_args
         cmp dl, T_PAIR
         je .push_arg
         jmp .wrong_type
.push_arg:
    CAR r10, rsi
    CDR rsi, rsi
    push r10
    inc r8
    jmp .get_list_params

.pre_rearange_args:
    xor r10 , r10 ;; we will use a counter
    mov r11 , r8 
    dec r11

.rearange_args:
    cmp r10, r11
    jge .pre_push_rest_args 
    mov r14, [rsp + 8 * r10]
    mov r15, [rsp + 8 * r11]
    mov [rsp + 8 * r10], r15
    mov [rsp + 8 * r11], r14
    inc r10
    dec r11
    jmp .rearange_args
.pre_push_rest_args:
    mov r9 , PARAM_COUNT
    sub r9, 2
.push_rest_args:
    cmp r9, 0 
    jle .end_stack
    mov rsi, PVAR(r9)
    push rsi
    dec r9
    jmp .push_rest_args
.end_stack:
    mov r9 , PARAM_COUNT
    sub r9, 2 ;; remember proc is also an argument
    add r9, r8
    push r9 ;; push arg count
    mov rsi ,PVAR(0)
    cmp byte [rsi], T_CLOSURE
    jne .wrong_type
    CLOSURE_ENV rdi,rsi
    push rdi ;; push closure env
    push qword [rbp + 8] ;; push ret adress
    mov r15, qword [rbp] ;;save old rbp
    
 .shift_frame:
    add r9 , 5
    SHIFT_FRAME_2 r9
    
  
  .end:  
  mov rbp,r15
  jmp qword [rsi+9]
  add rsp , 8*1 ; pop env
  pop rbx ; pop arg count
  inc rbx ; for remove magic
  shl rbx , 3 ; rbx = rbx * 8
  add rsp , rbx ;  pop args
  jmp .return 
.wrong_type:
    mov     rax, 60               ; system call 60 is exit
    xor     rdi,rdi           ;return code 0
    syscall 
.return:
    leave
    ret  
