
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
malloc_pointer:
    resq 1
    

section .data

%define WORD_BYTES 8

%macro MAKE_LITERAL 2
db %1
%2
%endmacro

%macro MAKE_LITERAL_INT 1 
	MAKE_LITERAL T_INTEGER, dq %1
%endmacro

%macro MAKE_LITERAL_CHAR 1
	MAKE_LITERAL T_CHAR, db %1
%endmacro

%macro MAKE_LITERAL_FLOAT 1 
	MAKE_LITERAL T_FLOAT, dq %1
%endmacro

%macro MAKE_LITERAL_SYMBOL 1 
	MAKE_LITERAL T_SYMBOL, dq %1
%endmacro

%define MAKE_NIL db T_NIL
%define MAKE_VOID db T_VOID
%define MAKE_BOOL (val) MAKE_LITERAL T_BOOL, db val




%define MAKE_INT(r,val) MAKE_LONG_VALUE r, val, T_INTEGER
%define MAKE_FLOAT(r,val) MAKE_LONG_VALUE r, val, T_FLOAT
%define MAKE_CHAR(r,val) MAKE_CHAR_VALUE r, val

%macro MAKE_LITERAL_STRING 0-*
db T_STRING
dq %0
%rep %0
db %1
%rotate 1
%endrep
%endmacro


%define PARAM_COUNT qword [rbp+3*WORD_SIZE]


notACLosureError: ;;there was a dot before this line!
	db "Error: trying to apply not-a-closure", 0
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_LITERAL T_BOOL, db 0
MAKE_LITERAL T_BOOL, db 1
MAKE_LITERAL_STRING 119, 104, 97, 116, 101, 118, 101, 114 
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_INT 0
MAKE_LITERAL_INT 1
MAKE_LITERAL_STRING 116, 104, 105, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 110, 32, 101, 114, 114, 111, 114, 44, 32, 98, 117, 116, 32, 121, 111, 117, 32, 100, 111, 110, 39, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 115 
MAKE_LITERAL_CHAR 0
;;
;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4



fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
global main
section .text
main:
  push rbp
  mov rbp, rsp
    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword 7 ;SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    call code_fragment ;;was jmp before!! 
    add rsp, 4*8
    leave
    ret

code_fragment:
push rbp
mov rbp, rsp
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl + 0], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl + 8], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl + 16], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl + 24], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl + 32], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl + 40], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_vector)
    mov [fvar_tbl + 48], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl + 56], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl + 64], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl + 72], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl + 80], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl + 88], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl + 96], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl + 104], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_length)
    mov [fvar_tbl + 112], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_ref)
    mov [fvar_tbl + 120], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_set)
    mov [fvar_tbl + 128], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_vector)
    mov [fvar_tbl + 136], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl + 144], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl + 152], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl + 160], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl + 168], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl + 176], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl + 184], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl + 192], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl + 200], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl + 208], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl + 216], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl + 224], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl + 232], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl + 240], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl + 248], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
    mov [fvar_tbl + 256], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
    mov [fvar_tbl + 264], rax
 ;;add rsp, 4*8
 ;;pop rbp
 ;;ret
 
 forDebug:
;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+256]
 push rax
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 4
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode0)
jmp Lcont0
Lcode0:
 push rbp
mov rbp, rsp

;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt4:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt4
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt4
copyParamsEndLoopOpt4:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt0)
jmp LcontOpt0
LcodeOpt0:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil0

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop0:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop0

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack0:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack0


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN0

	    shiftStackAndPushNil0:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil0:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil0

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN0:
	 	mov qword [rbp + 3*8], 1
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
;const
mov rax    , const_tbl + 1
 push rax
push 2
;applic
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple3:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple3
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple3
copyParamsEndLoopSimple3:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode1)
jmp Lcont1
Lcode1:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple2:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple2
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple2
copyParamsEndLoopSimple2:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode2)
jmp Lcont2
Lcode2:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure9

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic9

NotAClosure9:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic9:

cmp rax, SOB_FALSE_ADDRESS
je Lelse0
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
jmp LexitIf0
Lelse0:
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;applic
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 40 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 24] ;go to lexical env , tmp val is in r8
mov qword [r9 + 32], r8
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple1:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple1
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple1
copyParamsEndLoopSimple1:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode3)
jmp Lcont3
Lcode3:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 48 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 32] ;go to lexical env , tmp val is in r8
mov qword [r9 + 40], r8
mov qword r8, [rbx + 24] ;go to lexical env , tmp val is in r8
mov qword [r9 + 32], r8
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple0:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple0
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple0
copyParamsEndLoopSimple0:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode4)
jmp Lcont4
Lcode4:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 4]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure8

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic8

NotAClosure8:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic8:

cmp rax, SOB_FALSE_ADDRESS
je Lelse1
;applicTP
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 4]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure6

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic6

NotAClosure6:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic6:

 push rax
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 4]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure7

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic7

NotAClosure7:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic7:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP3

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP3:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP3

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP3:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf1
Lelse1:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 4]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure4

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic4

NotAClosure4:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic4:

 push rax
push 1
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure3

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic3

NotAClosure3:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic3:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 4]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure5

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic5

NotAClosure5:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic5:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 4]
mov rax, qword [rax + 8 * 3]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP2

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP2:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP2

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP2:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf1:
leave
ret
Lcont4:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]


leave
ret
Lcont3:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure2

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic2

NotAClosure2:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic2:

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP1

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP1:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP1

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP1:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf0:
leave
ret
Lcont2:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]


leave
ret
Lcont1:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure1

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic1

NotAClosure1:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic1:

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP0

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP0:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP0

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP0:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
LcontOpt0:
 
leave
ret
Lcont0:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure0

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic0

NotAClosure0:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic0:

mov qword [fvar_tbl+272], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+216]
 push rax
push 1
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode5)
jmp Lcont5
Lcode5:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple5:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple5
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple5
copyParamsEndLoopSimple5:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode6)
jmp Lcont6
Lcode6:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 32
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP4

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP4:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP4

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP4:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont6:
 
leave
ret
Lcont5:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure10

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic10

NotAClosure10:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic10:

mov qword [fvar_tbl+280], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;LambdaOpt
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, LcodeOpt1)
jmp LcontOpt1
LcodeOpt1:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil1

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop1:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop1

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack1:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack1


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN1

	    shiftStackAndPushNil1:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil1:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil1

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN1:
	 	mov qword [rbp + 3*8], 1
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
leave
ret
LcontOpt1:
 
mov qword [fvar_tbl+288], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+24]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 3
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode7)
jmp Lcont7
Lcode7:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple6:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple6
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple6
copyParamsEndLoopSimple6:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode8)
jmp Lcont8
Lcode8:
 push rbp
mov rbp, rsp

;or
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure12

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic12

NotAClosure12:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic12:

 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr0
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure14

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic14

NotAClosure14:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic14:

cmp rax, SOB_FALSE_ADDRESS
je Lelse2
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure13

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic13

NotAClosure13:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic13:

 push rax
push 1
;varFree
mov rax, qword [fvar_tbl+296]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP5

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP5:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP5

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP5:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf2
Lelse2:
;const
mov rax    , const_tbl + 2
LexitIf2:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr0
LexitOr0:

leave
ret
Lcont8:
 
leave
ret
Lcont7:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure11

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic11

NotAClosure11:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic11:

mov qword [fvar_tbl+296], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+176]
 push rax
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+24]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 4
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode9)
jmp Lcont9
Lcode9:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple9:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple9
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple9
copyParamsEndLoopSimple9:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode10)
jmp Lcont10
Lcode10:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
;const
mov rax    , const_tbl + 23
 push rax
push 2
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple8:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple8
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple8
copyParamsEndLoopSimple8:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode11)
jmp Lcont11
Lcode11:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;seq
;set(vatParam)
;const
mov rax    , const_tbl + 32
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;boxSet
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple7:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple7
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple7
copyParamsEndLoopSimple7:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode12)
jmp Lcont12
Lcode12:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure19

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic19

NotAClosure19:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic19:

cmp rax, SOB_FALSE_ADDRESS
je Lelse3
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
jmp LexitIf3
Lelse3:
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure18

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic18

NotAClosure18:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic18:

cmp rax, SOB_FALSE_ADDRESS
je Lelse4
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;const
mov rax    , const_tbl + 41
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure16

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic16

NotAClosure16:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic16:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure17

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic17

NotAClosure17:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic17:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP7

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP7:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP7

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP7:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf4
Lelse4:
;const
mov rax    , const_tbl + 50
LexitIf4:
LexitIf3:
leave
ret
Lcont12:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applicTP
;const
mov rax    , const_tbl + 32
 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 2
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP8

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP8:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP8

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP8:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall



leave
ret
Lcont11:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP6

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP6:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP6

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP6:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont10:
 
leave
ret
Lcont9:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure15

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic15

NotAClosure15:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic15:

mov qword [fvar_tbl+304], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+304]
 push rax
;varFree
mov rax, qword [fvar_tbl+216]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+104]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 5
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode13)
jmp Lcont13
Lcode13:
 push rbp
mov rbp, rsp

;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt10:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt10
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt10
copyParamsEndLoopOpt10:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt2)
jmp LcontOpt2
LcodeOpt2:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 1
	    cmp rax, 0
	    je shiftStackAndPushNil2

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop2:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop2

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 1;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 1 ; r10 = optCount - 1
	    shiftStack2:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack2


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN2

	    shiftStackAndPushNil2:
	    mov rcx, 4 + 1;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil2:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil2

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN2:
	 	mov qword [rbp + 3*8], 2
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure24

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic24

NotAClosure24:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic24:

cmp rax, SOB_FALSE_ADDRESS
je Lelse5
;applicTP
;const
mov rax    , const_tbl + 116
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP10

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP10:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP10

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP10:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf5
Lelse5:
;if
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure23

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic23

NotAClosure23:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic23:

 push rax
;const
mov rax    , const_tbl + 41
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure22

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic22

NotAClosure22:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic22:

cmp rax, SOB_FALSE_ADDRESS
je Lelse6
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure21

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic21

NotAClosure21:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic21:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP9

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP9:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP9

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP9:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf6
Lelse6:
;const
mov rax    , const_tbl + 50
LexitIf6:
LexitIf5:
leave
ret
LcontOpt2:
 
leave
ret
Lcont13:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure20

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic20

NotAClosure20:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic20:

mov qword [fvar_tbl+104], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+136]
 push rax
;varFree
mov rax, qword [fvar_tbl+304]
 push rax
push 4
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode14)
jmp Lcont14
Lcode14:
 push rbp
mov rbp, rsp

;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt11:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt11
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt11
copyParamsEndLoopOpt11:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt3)
jmp LcontOpt3
LcodeOpt3:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 1
	    cmp rax, 0
	    je shiftStackAndPushNil3

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop3:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop3

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 1;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 1 ; r10 = optCount - 1
	    shiftStack3:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack3


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN3

	    shiftStackAndPushNil3:
	    mov rcx, 4 + 1;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil3:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil3

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN3:
	 	mov qword [rbp + 3*8], 2
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure29

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic29

NotAClosure29:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic29:

cmp rax, SOB_FALSE_ADDRESS
je Lelse7
;applicTP
;const
mov rax    , const_tbl + 32
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP12

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP12:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP12

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP12:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf7
Lelse7:
;if
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure28

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic28

NotAClosure28:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic28:

 push rax
;const
mov rax    , const_tbl + 41
 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+216]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure27

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic27

NotAClosure27:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic27:

cmp rax, SOB_FALSE_ADDRESS
je Lelse8
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure26

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic26

NotAClosure26:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic26:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP11

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP11:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP11

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP11:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf8
Lelse8:
;const
mov rax    , const_tbl + 50
LexitIf8:
LexitIf7:
leave
ret
LcontOpt3:
 
leave
ret
Lcont14:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure25

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic25

NotAClosure25:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic25:

mov qword [fvar_tbl+136], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+168]
 push rax
push 1
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode15)
jmp Lcont15
Lcode15:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple12:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple12
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple12
copyParamsEndLoopSimple12:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode16)
jmp Lcont16
Lcode16:
 push rbp
mov rbp, rsp

;if
;applic
;const
mov rax    , const_tbl + 4
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure31

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic31

NotAClosure31:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic31:

cmp rax, SOB_FALSE_ADDRESS
je Lelse9
;const
mov rax    , const_tbl + 2
jmp LexitIf9
Lelse9:
;const
mov rax    , const_tbl + 4
LexitIf9:
leave
ret
Lcont16:
 
leave
ret
Lcont15:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure30

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic30

NotAClosure30:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic30:

mov qword [fvar_tbl+312], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+16]
 push rax
;varFree
mov rax, qword [fvar_tbl+8]
 push rax
push 2
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode17)
jmp Lcont17
Lcode17:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple13:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple13
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple13
copyParamsEndLoopSimple13:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode18)
jmp Lcont18
Lcode18:
 push rbp
mov rbp, rsp

;or
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure33

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic33

NotAClosure33:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic33:

 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr1
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP13

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP13:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP13

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP13:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr1
LexitOr1:

leave
ret
Lcont18:
 
leave
ret
Lcont17:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure32

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic32

NotAClosure32:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic32:

mov qword [fvar_tbl+320], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+264]
 push rax
;varFree
mov rax, qword [fvar_tbl+256]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 5
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode19)
jmp Lcont19
Lcode19:
 push rbp
mov rbp, rsp

;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt20:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt20
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt20
copyParamsEndLoopOpt20:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt4)
jmp LcontOpt4
LcodeOpt4:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 2
	    cmp rax, 0
	    je shiftStackAndPushNil4

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop4:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop4

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 2;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 2 ; r10 = optCount - 1
	    shiftStack4:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack4


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN4

	    shiftStackAndPushNil4:
	    mov rcx, 4 + 2;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil4:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil4

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN4:
	 	mov qword [rbp + 3*8], 3
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure47

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic47

NotAClosure47:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic47:

cmp rax, SOB_FALSE_ADDRESS
je Lelse10
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple19:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple19
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple19
copyParamsEndLoopSimple19:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode23)
jmp Lcont23
Lcode23:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple18:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple18
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple18
copyParamsEndLoopSimple18:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode24)
jmp Lcont24
Lcode24:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 40 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 24] ;go to lexical env , tmp val is in r8
mov qword [r9 + 32], r8
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple17:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple17
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple17
copyParamsEndLoopSimple17:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode25)
jmp Lcont25
Lcode25:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure46

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic46

NotAClosure46:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic46:

cmp rax, SOB_FALSE_ADDRESS
je Lelse12
;const
mov rax    , const_tbl + 1
jmp LexitIf12
Lelse12:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure43

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic43

NotAClosure43:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic43:

 push rax
push 1
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure42

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic42

NotAClosure42:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic42:

 push rax
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure45

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic45

NotAClosure45:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic45:

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure44

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic44

NotAClosure44:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic44:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP20

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP20:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP20

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP20:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf12:
leave
ret
Lcont25:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applicTP
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 1
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP21

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP21:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP21

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP21:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall



leave
ret
Lcont24:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP19

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP19:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP19

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP19:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont23:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP18

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP18:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP18

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP18:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf10
Lelse10:
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 2
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple16:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple16
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple16
copyParamsEndLoopSimple16:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode20)
jmp Lcont20
Lcode20:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple15:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple15
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple15
copyParamsEndLoopSimple15:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode21)
jmp Lcont21
Lcode21:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 40 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 24] ;go to lexical env , tmp val is in r8
mov qword [r9 + 32], r8
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple14:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple14
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple14
copyParamsEndLoopSimple14:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode22)
jmp Lcont22
Lcode22:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure41

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic41

NotAClosure41:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic41:

cmp rax, SOB_FALSE_ADDRESS
je Lelse11
;const
mov rax    , const_tbl + 1
jmp LexitIf11
Lelse11:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 4]

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+328]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure36

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic36

NotAClosure36:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic36:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure37

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic37

NotAClosure37:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic37:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure35

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic35

NotAClosure35:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic35:

 push rax
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 3]

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+328]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure39

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic39

NotAClosure39:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic39:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure40

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic40

NotAClosure40:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic40:

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

 push rax
push 3
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure38

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic38

NotAClosure38:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic38:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP16

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP16:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP16

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP16:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf11:
leave
ret
Lcont22:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applicTP
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 2
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP17

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP17:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP17

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP17:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall



leave
ret
Lcont21:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP15

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP15:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP15

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP15:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont20:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP14

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP14:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP14

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP14:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf10:
leave
ret
LcontOpt4:
 
leave
ret
Lcont19:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure34

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic34

NotAClosure34:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic34:

mov qword [fvar_tbl+328], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+176]
 push rax
;varFree
mov rax, qword [fvar_tbl+304]
 push rax
;varFree
mov rax, qword [fvar_tbl+136]
 push rax
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+24]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 7
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode26)
jmp Lcont26
Lcode26:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple23:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple23
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple23
copyParamsEndLoopSimple23:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode27)
jmp Lcont27
Lcode27:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple22:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple22
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple22
copyParamsEndLoopSimple22:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode28)
jmp Lcont28
Lcode28:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple21:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple21
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple21
copyParamsEndLoopSimple21:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode29)
jmp Lcont29
Lcode29:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure54

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic54

NotAClosure54:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic54:

cmp rax, SOB_FALSE_ADDRESS
je Lelse13
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
jmp LexitIf13
Lelse13:
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure53

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic53

NotAClosure53:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic53:

cmp rax, SOB_FALSE_ADDRESS
je Lelse14
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
;const
mov rax    , const_tbl + 41
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 6]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure49

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic49

NotAClosure49:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic49:

 push rax
;seq
;seq
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure51

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic51

NotAClosure51:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic51:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 3
;varFree
mov rax, qword [fvar_tbl+128]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure50

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic50

NotAClosure50:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic50:

;varParam
 mov rax, qword [rbp + 8*(4 + 1)]

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure52

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic52

NotAClosure52:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic52:

 push rax
push 3
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP23

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 6 ;;check! maybe add 4 instead
mov r12, 1
LoopTP23:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP23

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP23:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf14
Lelse14:
;const
mov rax    , const_tbl + 50
LexitIf14:
LexitIf13:
leave
ret
Lcont29:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applicTP
;const
mov rax    , const_tbl + 32
 push rax
;applic
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure56

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic56

NotAClosure56:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic56:

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure55

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic55

NotAClosure55:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic55:

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 3
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP24

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 6 ;;check! maybe add 4 instead
mov r12, 1
LoopTP24:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP24

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP24:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall



leave
ret
Lcont28:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP22

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP22:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP22

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP22:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont27:
 
leave
ret
Lcont26:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure48

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic48

NotAClosure48:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic48:

mov qword [fvar_tbl+336], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+192]
 push rax
;varFree
mov rax, qword [fvar_tbl+112]
 push rax
;varFree
mov rax, qword [fvar_tbl+256]
 push rax
;varFree
mov rax, qword [fvar_tbl+120]
 push rax
;varFree
mov rax, qword [fvar_tbl+208]
 push rax
push 5
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode30)
jmp Lcont30
Lcode30:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple26:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple26
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple26
copyParamsEndLoopSimple26:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode31)
jmp Lcont31
Lcode31:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple25:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple25
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple25
copyParamsEndLoopSimple25:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode32)
jmp Lcont32
Lcode32:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple24:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple24
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple24
copyParamsEndLoopSimple24:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode33)
jmp Lcont33
Lcode33:
 push rbp
mov rbp, rsp

;if
;applic
;const
mov rax    , const_tbl + 32
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure61

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic61

NotAClosure61:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic61:

cmp rax, SOB_FALSE_ADDRESS
je Lelse15
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
jmp LexitIf15
Lelse15:
;applicTP
;applic
;const
mov rax    , const_tbl + 41
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure58

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic58

NotAClosure58:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic58:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure60

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic60

NotAClosure60:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic60:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure59

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic59

NotAClosure59:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic59:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 3
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP26

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 6 ;;check! maybe add 4 instead
mov r12, 1
LoopTP26:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP26

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP26:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf15:
leave
ret
Lcont33:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applicTP
;applic
;const
mov rax    , const_tbl + 41
 push rax
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure63

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic63

NotAClosure63:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic63:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure62

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic62

NotAClosure62:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic62:

 push rax
;const
mov rax    , const_tbl + 1
 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 3
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP27

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 6 ;;check! maybe add 4 instead
mov r12, 1
LoopTP27:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP27

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP27:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall



leave
ret
Lcont32:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP25

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP25:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP25

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP25:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont31:
 
leave
ret
Lcont30:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure57

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic57

NotAClosure57:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic57:

mov qword [fvar_tbl+344], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+336]
 push rax
push 1
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode34)
jmp Lcont34
Lcode34:
 push rbp
mov rbp, rsp

;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt27:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt27
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt27
copyParamsEndLoopOpt27:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt5)
jmp LcontOpt5
LcodeOpt5:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil5

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop5:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop5

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack5:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack5


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN5

	    shiftStackAndPushNil5:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil5:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil5

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN5:
	 	mov qword [rbp + 3*8], 1
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP28

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP28:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP28

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP28:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
LcontOpt5:
 
leave
ret
Lcont34:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure64

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic64

NotAClosure64:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic64:

mov qword [fvar_tbl+352], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+264]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+176]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 5
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode35)
jmp Lcont35
Lcode35:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple29:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple29
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple29
copyParamsEndLoopSimple29:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode36)
jmp Lcont36
Lcode36:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt28:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt28
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt28
copyParamsEndLoopOpt28:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt6)
jmp LcontOpt6
LcodeOpt6:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil6

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop6:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop6

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack6:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack6


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN6

	    shiftStackAndPushNil6:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil6:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil6

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN6:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure69

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic69

NotAClosure69:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic69:

cmp rax, SOB_FALSE_ADDRESS
je Lelse16
;const
mov rax    , const_tbl + 32
jmp LexitIf16
Lelse16:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure67

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic67

NotAClosure67:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic67:

 push rax
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure66

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic66

NotAClosure66:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic66:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure68

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic68

NotAClosure68:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic68:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP30

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP30:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP30

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP30:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf16:
leave
ret
LcontOpt6:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]


leave
ret
Lcont36:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP29

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP29:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP29

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP29:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont35:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure65

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic65

NotAClosure65:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic65:

mov qword [fvar_tbl+176], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+264]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+184]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 5
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode37)
jmp Lcont37
Lcode37:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple31:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple31
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple31
copyParamsEndLoopSimple31:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode38)
jmp Lcont38
Lcode38:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt30:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt30
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt30
copyParamsEndLoopOpt30:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt7)
jmp LcontOpt7
LcodeOpt7:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil7

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop7:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop7

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack7:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack7


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN7

	    shiftStackAndPushNil7:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil7:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil7

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN7:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure74

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic74

NotAClosure74:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic74:

cmp rax, SOB_FALSE_ADDRESS
je Lelse17
;const
mov rax    , const_tbl + 41
jmp LexitIf17
Lelse17:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure72

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic72

NotAClosure72:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic72:

 push rax
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure71

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic71

NotAClosure71:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic71:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure73

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic73

NotAClosure73:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic73:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP32

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP32:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP32

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP32:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf17:
leave
ret
LcontOpt7:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]


leave
ret
Lcont38:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP31

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP31:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP31

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP31:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont37:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure70

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic70

NotAClosure70:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic70:

mov qword [fvar_tbl+184], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+304]
 push rax
;varFree
mov rax, qword [fvar_tbl+264]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+176]
 push rax
;varFree
mov rax, qword [fvar_tbl+192]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 7
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode39)
jmp Lcont39
Lcode39:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple34:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple34
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple34
copyParamsEndLoopSimple34:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode40)
jmp Lcont40
Lcode40:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt32:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt32
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt32
copyParamsEndLoopOpt32:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt8)
jmp LcontOpt8
LcodeOpt8:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil8

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop8:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop8

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack8:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack8


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN8

	    shiftStackAndPushNil8:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil8:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil8

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN8:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure79

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic79

NotAClosure79:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic79:

cmp rax, SOB_FALSE_ADDRESS
je Lelse18
;const
mov rax    , const_tbl + 32
jmp LexitIf18
Lelse18:
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure76

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic76

NotAClosure76:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic76:

 push rax
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure78

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic78

NotAClosure78:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic78:

 push rax
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure77

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic77

NotAClosure77:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic77:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP34

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP34:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP34

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP34:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf18:
leave
ret
LcontOpt8:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt33:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt33
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt33
copyParamsEndLoopOpt33:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt9)
jmp LcontOpt9
LcodeOpt9:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil9

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop9:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop9

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack9:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack9


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN9

	    shiftStackAndPushNil9:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil9:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil9

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN9:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure86

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic86

NotAClosure86:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic86:

cmp rax, SOB_FALSE_ADDRESS
je Lelse19
;const
mov rax    , const_tbl + 50
jmp LexitIf19
Lelse19:
;if
;applic
;const
mov rax    , const_tbl + 41
 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure85

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic85

NotAClosure85:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic85:

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+216]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure84

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic84

NotAClosure84:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic84:

cmp rax, SOB_FALSE_ADDRESS
je Lelse20
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure83

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic83

NotAClosure83:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic83:

 push rax
;const
mov rax    , const_tbl + 32
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP36

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP36:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP36

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP36:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf20
Lelse20:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure81

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic81

NotAClosure81:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic81:

 push rax
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure80

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic80

NotAClosure80:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic80:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure82

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic82

NotAClosure82:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic82:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP35

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP35:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP35

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP35:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf20:
LexitIf19:
leave
ret
LcontOpt9:
 


leave
ret
Lcont40:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP33

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP33:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP33

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP33:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont39:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure75

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic75

NotAClosure75:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic75:

mov qword [fvar_tbl+192], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+304]
 push rax
;varFree
mov rax, qword [fvar_tbl+264]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+184]
 push rax
;varFree
mov rax, qword [fvar_tbl+200]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 7
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode41)
jmp Lcont41
Lcode41:
 push rbp
mov rbp, rsp

;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt35:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt35
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt35
copyParamsEndLoopOpt35:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt10)
jmp LcontOpt10
LcodeOpt10:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil10

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop10:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop10

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack10:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack10


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN10

	    shiftStackAndPushNil10:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil10:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil10

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN10:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure94

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic94

NotAClosure94:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic94:

cmp rax, SOB_FALSE_ADDRESS
je Lelse21
;const
mov rax    , const_tbl + 50
jmp LexitIf21
Lelse21:
;if
;applic
;const
mov rax    , const_tbl + 41
 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 5]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure93

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic93

NotAClosure93:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic93:

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+216]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure92

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic92

NotAClosure92:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic92:

cmp rax, SOB_FALSE_ADDRESS
je Lelse22
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure91

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic91

NotAClosure91:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic91:

 push rax
;const
mov rax    , const_tbl + 41
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP38

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP38:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP38

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP38:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf22
Lelse22:
;applicTP
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 6]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure89

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic89

NotAClosure89:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic89:

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure88

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic88

NotAClosure88:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic88:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure90

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic90

NotAClosure90:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic90:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP37

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP37:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP37

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP37:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf22:
LexitIf21:
leave
ret
LcontOpt10:
 
leave
ret
Lcont41:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure87

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic87

NotAClosure87:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic87:

mov qword [fvar_tbl+200], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+216]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 4
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode42)
jmp Lcont42
Lcode42:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple38:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple38
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple38
copyParamsEndLoopSimple38:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode43)
jmp Lcont43
Lcode43:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple36:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple36
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple36
copyParamsEndLoopSimple36:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode44)
jmp Lcont44
Lcode44:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure100

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic100

NotAClosure100:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic100:

cmp rax, SOB_FALSE_ADDRESS
je Lelse23
;const
mov rax    , const_tbl + 4
jmp LexitIf23
Lelse23:
;if
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure99

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic99

NotAClosure99:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic99:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure98

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic98

NotAClosure98:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic98:

cmp rax, SOB_FALSE_ADDRESS
je Lelse24
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure96

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic96

NotAClosure96:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic96:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure97

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic97

NotAClosure97:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic97:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP40

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP40:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP40

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP40:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf24
Lelse24:
;const
mov rax    , const_tbl + 2
LexitIf24:
LexitIf23:
leave
ret
Lcont44:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt37:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt37
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt37
copyParamsEndLoopOpt37:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt11)
jmp LcontOpt11
LcodeOpt11:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil11

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop11:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop11

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack11:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack11


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN11

	    shiftStackAndPushNil11:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil11:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil11

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN11:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure103

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic103

NotAClosure103:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic103:

cmp rax, SOB_FALSE_ADDRESS
je Lelse25
;const
mov rax    , const_tbl + 50
jmp LexitIf25
Lelse25:
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure101

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic101

NotAClosure101:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic101:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure102

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic102

NotAClosure102:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic102:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP41

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP41:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP41

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP41:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf25:
leave
ret
LcontOpt11:
 


leave
ret
Lcont43:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP39

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP39:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP39

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP39:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont42:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure95

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic95

NotAClosure95:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic95:

mov qword [fvar_tbl+216], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+208]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 4
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode45)
jmp Lcont45
Lcode45:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple41:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple41
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple41
copyParamsEndLoopSimple41:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode46)
jmp Lcont46
Lcode46:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple39:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple39
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple39
copyParamsEndLoopSimple39:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode47)
jmp Lcont47
Lcode47:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure109

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic109

NotAClosure109:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic109:

cmp rax, SOB_FALSE_ADDRESS
je Lelse26
;const
mov rax    , const_tbl + 4
jmp LexitIf26
Lelse26:
;if
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure108

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic108

NotAClosure108:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic108:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure107

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic107

NotAClosure107:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic107:

cmp rax, SOB_FALSE_ADDRESS
je Lelse27
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure105

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic105

NotAClosure105:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic105:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure106

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic106

NotAClosure106:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic106:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP43

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP43:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP43

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP43:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf27
Lelse27:
;const
mov rax    , const_tbl + 2
LexitIf27:
LexitIf26:
leave
ret
Lcont47:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt40:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt40
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt40
copyParamsEndLoopOpt40:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt12)
jmp LcontOpt12
LcodeOpt12:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil12

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop12:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop12

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack12:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack12


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN12

	    shiftStackAndPushNil12:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil12:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil12

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN12:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure112

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic112

NotAClosure112:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic112:

cmp rax, SOB_FALSE_ADDRESS
je Lelse28
;const
mov rax    , const_tbl + 50
jmp LexitIf28
Lelse28:
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure110

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic110

NotAClosure110:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic110:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure111

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic111

NotAClosure111:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic111:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP44

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP44:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP44

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP44:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf28:
leave
ret
LcontOpt12:
 


leave
ret
Lcont46:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP42

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP42:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP42

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP42:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont45:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure104

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic104

NotAClosure104:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic104:

mov qword [fvar_tbl+208], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+312]
 push rax
;varFree
mov rax, qword [fvar_tbl+216]
 push rax
;varFree
mov rax, qword [fvar_tbl+208]
 push rax
;varFree
mov rax, qword [fvar_tbl+32]
 push rax
push 6
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode48)
jmp Lcont48
Lcode48:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple44:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple44
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple44
copyParamsEndLoopSimple44:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode49)
jmp Lcont49
Lcode49:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple42:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple42
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple42
copyParamsEndLoopSimple42:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode50)
jmp Lcont50
Lcode50:
 push rbp
mov rbp, rsp

;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure121

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic121

NotAClosure121:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic121:

cmp rax, SOB_FALSE_ADDRESS
je Lelse29
;const
mov rax    , const_tbl + 4
jmp LexitIf29
Lelse29:
;if
;applic
;or
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure118

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic118

NotAClosure118:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic118:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure117

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic117

NotAClosure117:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic117:

 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr2
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure120

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic120

NotAClosure120:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic120:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure119

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic119

NotAClosure119:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic119:

 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr2
LexitOr2:

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure116

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic116

NotAClosure116:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic116:

cmp rax, SOB_FALSE_ADDRESS
je Lelse30
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure114

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic114

NotAClosure114:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic114:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure115

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic115

NotAClosure115:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic115:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP46

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP46:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP46

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP46:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf30
Lelse30:
;const
mov rax    , const_tbl + 2
LexitIf30:
LexitIf29:
leave
ret
Lcont50:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;LambdaOpt
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt43:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt43
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt43
copyParamsEndLoopOpt43:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt13)
jmp LcontOpt13
LcodeOpt13:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil13

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop13:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop13

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack13:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack13


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN13

	    shiftStackAndPushNil13:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil13:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil13

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN13:
	 	mov qword [rbp + 3*8], 1
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure124

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic124

NotAClosure124:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic124:

cmp rax, SOB_FALSE_ADDRESS
je Lelse31
;const
mov rax    , const_tbl + 50
jmp LexitIf31
Lelse31:
;applicTP
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure122

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic122

NotAClosure122:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic122:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure123

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic123

NotAClosure123:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic123:

 push rax
push 2
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP47

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP47:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP47

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP47:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf31:
leave
ret
LcontOpt13:
 


leave
ret
Lcont49:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP45

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP45:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP45

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP45:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont48:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure113

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic113

NotAClosure113:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic113:

mov qword [fvar_tbl+360], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;define(Var'(VarFree))
;applic
;varFree
mov rax, qword [fvar_tbl+192]
 push rax
;varFree
mov rax, qword [fvar_tbl+152]
 push rax
;varFree
mov rax, qword [fvar_tbl+232]
 push rax
;varFree
mov rax, qword [fvar_tbl+224]
 push rax
;varFree
mov rax, qword [fvar_tbl+168]
 push rax
;varFree
mov rax, qword [fvar_tbl+48]
 push rax
;varFree
mov rax, qword [fvar_tbl+56]
 push rax
;varFree
mov rax, qword [fvar_tbl+40]
 push rax
;varFree
mov rax, qword [fvar_tbl+24]
 push rax
;varFree
mov rax, qword [fvar_tbl+8]
 push rax
;varFree
mov rax, qword [fvar_tbl+16]
 push rax
;varFree
mov rax, qword [fvar_tbl+112]
 push rax
;varFree
mov rax, qword [fvar_tbl+120]
 push rax
;varFree
mov rax, qword [fvar_tbl+88]
 push rax
;varFree
mov rax, qword [fvar_tbl+80]
 push rax
;varFree
mov rax, qword [fvar_tbl+312]
 push rax
;varFree
mov rax, qword [fvar_tbl+216]
 push rax
;varFree
mov rax, qword [fvar_tbl+208]
 push rax
push 18
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode51)
jmp Lcont51
Lcode51:
 push rbp
mov rbp, rsp

;applicTP
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple49:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple49
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple49
copyParamsEndLoopSimple49:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode54)
jmp Lcont54
Lcode54:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 23
 push rax
push 1
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple48:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple48
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple48
copyParamsEndLoopSimple48:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode55)
jmp Lcont55
Lcode55:
 push rbp
mov rbp, rsp

;seq
;seq
;set(vatParam)
;Box(var)
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
push rbx
MALLOC rbx, WORD_BYTES
mov [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp + 8*(4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;seq
;seq
;boxSet
;lambdaSimple
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple47:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple47
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple47
copyParamsEndLoopSimple47:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode56)
jmp Lcont56
Lcode56:
 push rbp
mov rbp, rsp

;if
;applic
;const
mov rax    , const_tbl + 32
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 3)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure155

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic155

NotAClosure155:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic155:

cmp rax, SOB_FALSE_ADDRESS
je Lelse45
;const
mov rax    , const_tbl + 4
jmp LexitIf45
Lelse45:
;if
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 3)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 2
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure153

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic153

NotAClosure153:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic153:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 3)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure154

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic154

NotAClosure154:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic154:

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+368]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure152

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic152

NotAClosure152:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic152:

cmp rax, SOB_FALSE_ADDRESS
je Lelse46
;applicTP
;applic
;const
mov rax    , const_tbl + 41
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 3)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 17]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure151

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic151

NotAClosure151:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic151:

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 2)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 4
;boxGet
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP51

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 7 ;;check! maybe add 4 instead
mov r12, 1
LoopTP51:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP51

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP51:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

jmp LexitIf46
Lelse46:
;const
mov rax    , const_tbl + 2
LexitIf46:
LexitIf45:
leave
ret
Lcont56:
 
push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;if
;applic
;applic
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure160

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic160

NotAClosure160:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic160:

 push rax
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure161

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic161

NotAClosure161:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic161:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure159

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic159

NotAClosure159:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic159:

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure158

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic158

NotAClosure158:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic158:

cmp rax, SOB_FALSE_ADDRESS
je Lelse47
;const
mov rax    , const_tbl + 2
jmp LexitIf47
Lelse47:
;applicTP
;applic
;const
mov rax    , const_tbl + 41
 push rax
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure157

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic157

NotAClosure157:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic157:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 17]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure156

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic156

NotAClosure156:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic156:

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 4
;boxGet
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
mov rax, qword [rax]
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP52

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 7 ;;check! maybe add 4 instead
mov r12, 1
LoopTP52:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP52

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP52:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

LexitIf47:


leave
ret
Lcont55:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP50

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP50:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP50

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP50:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont54:
 
 push rax
push 1
;lambdaSimple
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple46:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple46
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple46
copyParamsEndLoopSimple46:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode52)
jmp Lcont52
Lcode52:
 push rbp
mov rbp, rsp

;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple45:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple45
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple45
copyParamsEndLoopSimple45:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode53)
jmp Lcont53
Lcode53:
 push rbp
mov rbp, rsp

;or
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure128

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic128

NotAClosure128:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic128:

cmp rax, SOB_FALSE_ADDRESS
je Lelse32
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure127

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic127

NotAClosure127:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic127:

cmp rax, SOB_FALSE_ADDRESS
je Lelse33
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure126

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic126

NotAClosure126:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic126:

jmp LexitIf33
Lelse33:
;const
mov rax    , const_tbl + 2
LexitIf33:
jmp LexitIf32
Lelse32:
;const
mov rax    , const_tbl + 2
LexitIf32:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure131

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic131

NotAClosure131:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic131:

cmp rax, SOB_FALSE_ADDRESS
je Lelse34
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure130

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic130

NotAClosure130:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic130:

cmp rax, SOB_FALSE_ADDRESS
je Lelse35
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure129

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic129

NotAClosure129:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic129:

jmp LexitIf35
Lelse35:
;const
mov rax    , const_tbl + 2
LexitIf35:
jmp LexitIf34
Lelse34:
;const
mov rax    , const_tbl + 2
LexitIf34:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure139

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic139

NotAClosure139:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic139:

cmp rax, SOB_FALSE_ADDRESS
je Lelse36
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure138

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic138

NotAClosure138:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic138:

cmp rax, SOB_FALSE_ADDRESS
je Lelse37
;if
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 14]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure136

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic136

NotAClosure136:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic136:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 14]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure137

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic137

NotAClosure137:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic137:

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+368]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure135

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic135

NotAClosure135:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic135:

cmp rax, SOB_FALSE_ADDRESS
je Lelse38
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 15]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure133

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic133

NotAClosure133:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic133:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 15]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure134

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic134

NotAClosure134:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic134:

 push rax
push 2
;varFree
mov rax, qword [fvar_tbl+368]
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure132

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic132

NotAClosure132:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic132:

jmp LexitIf38
Lelse38:
;const
mov rax    , const_tbl + 2
LexitIf38:
jmp LexitIf37
Lelse37:
;const
mov rax    , const_tbl + 2
LexitIf37:
jmp LexitIf36
Lelse36:
;const
mov rax    , const_tbl + 2
LexitIf36:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure144

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic144

NotAClosure144:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic144:

cmp rax, SOB_FALSE_ADDRESS
je Lelse39
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure143

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic143

NotAClosure143:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic143:

cmp rax, SOB_FALSE_ADDRESS
je Lelse40
;applic
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 16]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure141

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic141

NotAClosure141:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic141:

 push rax
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 16]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure142

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic142

NotAClosure142:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic142:

 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure140

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic140

NotAClosure140:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic140:

jmp LexitIf40
Lelse40:
;const
mov rax    , const_tbl + 2
LexitIf40:
jmp LexitIf39
Lelse39:
;const
mov rax    , const_tbl + 2
LexitIf39:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 11]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure147

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic147

NotAClosure147:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic147:

cmp rax, SOB_FALSE_ADDRESS
je Lelse41
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 11]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure146

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic146

NotAClosure146:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic146:

cmp rax, SOB_FALSE_ADDRESS
je Lelse42
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 4
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure145

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic145

NotAClosure145:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic145:

jmp LexitIf42
Lelse42:
;const
mov rax    , const_tbl + 2
LexitIf42:
jmp LexitIf41
Lelse41:
;const
mov rax    , const_tbl + 2
LexitIf41:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 12]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure150

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic150

NotAClosure150:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic150:

cmp rax, SOB_FALSE_ADDRESS
je Lelse43
;if
;applic
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
push 1
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 12]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure149

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic149

NotAClosure149:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic149:

cmp rax, SOB_FALSE_ADDRESS
je Lelse44
;applic
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 4
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure148

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic148

NotAClosure148:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic148:

jmp LexitIf44
Lelse44:
;const
mov rax    , const_tbl + 2
LexitIf44:
jmp LexitIf43
Lelse43:
;const
mov rax    , const_tbl + 2
LexitIf43:
 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
;applicTP
;varParam
 mov rax, qword [rbp + 8*(4 + 1)]
 push rax
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
 push rax
push 2
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 13]

mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP49

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 5 ;;check! maybe add 4 instead
mov r12, 1
LoopTP49:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP49

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP49:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

 cmp rax, SOB_FALSE_ADDRESS
 jne LexitOr3
LexitOr3:

leave
ret
Lcont53:
 
leave
ret
Lcont52:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP48

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP48:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP48

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP48:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont51:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure125

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic125

NotAClosure125:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic125:

mov qword [fvar_tbl+368], rax
mov rax, SOB_VOID_ADDRESS
    call write_sob_if_not_void


;applic
push 0
;lambdaSimple
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode57)
jmp Lcont57
Lcode57:
 push rbp
mov rbp, rsp

;applicTP
;const
mov rax    , const_tbl + 4
 push rax
push 1
;LambdaOpt
MALLOC r9, 16 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt52:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt52
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt52
copyParamsEndLoopOpt52:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt14)
jmp LcontOpt14
LcodeOpt14:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil14

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop14:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop14

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack14:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack14


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN14

	    shiftStackAndPushNil14:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil14:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil14

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN14:
	 	mov qword [rbp + 3*8], 1
;applicTP
push 0
;lambdaSimple
MALLOC r9, 24 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopSimple51:
	       		cmp rcx, 0
	       		je copyParamsEndLoopSimple51
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopSimple51
copyParamsEndLoopSimple51:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, Lcode58)
jmp Lcont58
Lcode58:
 push rbp
mov rbp, rsp

;applicTP
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
;varBound
 mov rax, qword[rbp + 8*2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

 push rax
push 3
;LambdaOpt
MALLOC r9, 32 ;r9 = extEnv pointer
mov qword rbx, [rbp + 8 * 2] ;rbx is lexical env pointer
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
;copyEnvLoop - r9[i+1] = rbx[i]:
mov qword r8, [rbx + 16] ;go to lexical env , tmp val is in r8
mov qword [r9 + 24], r8
mov qword r8, [rbx + 8] ;go to lexical env , tmp val is in r8
mov qword [r9 + 16], r8
mov qword r8, [rbx + 0] ;go to lexical env , tmp val is in r8
mov qword [r9 + 8], r8

mov r13, qword [rbp+8*3] 
shl r13, 3
MALLOC rdx, r13 ;number of params of prev env * 8
mov rcx, qword [rbp+3*8] ; rcx = param count
	    	mov r12, 0 ; r12 = i 
	       copyParamsLoopOpt50:
	       		cmp rcx, 0
	       		je copyParamsEndLoopOpt50
mov r13, r12
	    		add r13, 4
	    		mov rbx, [rbp + 8*r13] ;rbx = param(i)
	    		mov [rdx + 8*r12], rbx ;rdx = extEnv[0], rdx[i] = rbx
	    		inc r12
	    		dec rcx
	    		jmp copyParamsLoopOpt50
copyParamsEndLoopOpt50:

mov qword [r9], rdx ;rdx is the params vector
MAKE_CLOSURE (rax, r9, LcodeOpt15)
jmp LcontOpt15
LcodeOpt15:
 push rbp
mov rbp, rsp
 

	    ;rax = num of opt params
	    mov rax, qword [rbp + 3*8]
	    sub rax, 0
	    cmp rax, 0
	    je shiftStackAndPushNil15

	    ;generate opt list
	    mov rdx, SOB_NIL_ADDRESS ; rdx = list
	    mov rcx, rax ; rcx = num of opt params
	    mov r9, qword [rbp + 8*3]
	    optToListLoop15:
	    	mov rbx, qword [rbp + 8*(r9+3)] ; rbx = OPTi
	    	MAKE_PAIR (r10, rbx, rdx) ;r10 = Pair(rbx, rdx)
	    	mov rdx, r10
	    	dec r9
	    	dec rcx
	    	jne optToListLoop15

	    ;override last OPT with the opt list
	    mov r9, qword [rbp + 8 *3]
	    add r9, 3 ;;r9 = [rbp + 3*8] + 3  = index of last opt
	   	mov qword [rbp + 8*r9], rdx

	    ;shift frame - shift size is (optCount - 1)
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, rcx
	    dec r12 ; r12 = index of last opt in stack
	    mov r10, qword [rbp + 8*3]
	    sub r10, 1 + 0 ; r10 = optCount - 1
	    shiftStack15:
	    	mov r8, qword [rbp+r12*8]
	    	mov r13, r12
	    	add r13 , r10
	       	mov [rbp+ 8*r13], r8
	    	dec r12 
	    	dec rcx
	    	jne shiftStack15


	    mov rax, r10
	    mov rbx, 8
	    mul rbx
	    add rbp, rax
	    add rsp, rax 

	    jmp fixN15

	    shiftStackAndPushNil15:
	    mov rcx, 4 + 0;rcx = frame size
	    mov r12, 0 ; r12 = i
	    shiftStackNil15:
	    	mov r8, qword [rbp+r12*8]
	       	mov [rbp+ 8*r12 - 8], r8
	    	inc r12 
	    	dec rcx
	    	jne shiftStackNil15

	    sub rbp, 8
	    sub rsp, 8

	    ;;push nil -- > check this!
	    mov r8, SOB_NIL_ADDRESS

	    ;override value *after* last opt with 
	    mov r9, qword [rbp + 8 *3]
	    add r9, 4 ;;r9 = [rbp + 3*8] + 4  = index of last opt
	   	mov qword [rbp + 8*r9], r8

	    ;fix n to be fixedParamsCount + 1:
	  	fixN15:
	 	mov qword [rbp + 3*8], 1
;varParam
 mov rax, qword [rbp + 8*(4 + 0)]
leave
ret
LcontOpt15:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP55

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 6 ;;check! maybe add 4 instead
mov r12, 1
LoopTP55:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP55

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP55:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont58:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP54

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 3 ;;check! maybe add 4 instead
mov r12, 1
LoopTP54:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP54

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP54:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
LcontOpt14:
 
mov r13, rax ;save closure
cmp byte [rax], T_CLOSURE
jne NotAClosureTP53

push qword [rax + TYPE_SIZE] ;push env
push qword [rbp + WORD_BYTES*1] ;old ret address
mov qword r10, [rbp] ; r10 = old old rbp
mov r11, PARAM_COUNT ; save old param count 

push rax
mov rax, PARAM_COUNT
add rax, 4
mov rcx, 4 ;;check! maybe add 4 instead
mov r12, 1
LoopTP53:
dec rax
mov r8, rbp
;push rax
;mov rax, WORD_SIZE
shl r12, 3
sub r8, r12
shr r12, 3
;pop rax
mov r8, [r8]  
mov [rbp+WORD_BYTES*rax], r8
inc r12
dec rcx
jnz LoopTP53

pop rax
;clean stack: add rsp , WORD_BYTES*(r11+4)
;push rax
;mov rax, WORD_SIZE
add r11, 4
shl r11,3
add rsp, r11
;pop rax

;pop rax
mov rbp, r10 ;risky line!!!!!  maybe save in rbp instead (brama) , save old old rbp
jmp [r13 + TYPE_SIZE + WORD_BYTES]
NotAClosureTP53:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall

leave
ret
Lcont57:
 
;check if closure 
cmp byte [rax], T_CLOSURE
jne NotAClosure162

push qword [rax+TYPE_SIZE]  ;push env:
call [rax+TYPE_SIZE+WORD_SIZE] ;call closure_code:

;cleaning the stack 
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
jmp FinishedApplic162

NotAClosure162:
	mov rdi, notACLosureError
	call print_string
	mov rax, 1
	syscall
FinishedApplic162:

    call write_sob_if_not_void
leave
 ret
apply:
        push rbp
        mov rbp, rsp
        mov r12, 0 ;; we will use to count number of args in list
        mov r11 , PARAM_COUNT
        sub r11, 1
        mov r10, PVAR(r11) ;; last argument is list -> rsi
        .pushListToStack:
         cmp byte [r10], T_NIL
         je .endPushList
    CAR r9, r10
    CDR r10, r10
    push r9
    add r12, 1
    jmp .pushListToStack

.endPushList:
    mov r8, 0 ;; we will use a counter
    mov r9 , r12 
    dec r9

.reverseStack:
    cmp r9, r8
    jle .endReverse 
    mov r15, [rsp + 8 * r9]
    mov r14, [rsp + 8 * r8]
    mov [rsp + 8 * r9], r14
    mov [rsp + 8 * r8], r15
    dec r9
    inc r8
    jmp .reverseStack
    
.endReverse:
    mov rcx , qword [rbp + 8*3]
    dec rcx ;remove proc arg
    dec rcx ;remove list arg
.pushRestArgs:
    cmp rcx, 0 
    jle .finishPushRest
    push PVAR(rcx)
    sub rcx, 1
    jmp .pushRestArgs
    
.finishPushRest:
    add r12, qword [rbp+8*3]
    sub r12, 2
    push r12 ;push arg count
    mov rax, qword [rbp + 8*4] ; rax = closure
    cmp byte [rax], T_CLOSURE
    jne .exit
    CLOSURE_ENV rdi,rax
    push rdi ; push closure env
    mov r15, qword [rbp] ; old rbp
    push qword [rbp + 8] ; push ret 
 
 
 .shift_frame:
    add r12 , 4
push rax
    mov rax, PARAM_COUNT
    add rax, 4
    mov r10, rax
    shl r10, 3 ;r10 = 8*frame size, save for later
    mov rcx, r12 ; loop index
    mov r9, 1 
  	
    .loopLabel:
    cmp rcx, 0
    je .cleanStack
    dec rcx
    dec rax
    mov r8, rbp
    mov rdi, r9
    shl rdi, 3
  	sub r8, rdi
  	mov r8, [r8] ;r8 = [rbp-i*8]
        mov [rbp + 8*rax], r8
  	inc r9
  	jne .loopLabel
    
    .cleanStack:
pop rax
    add rsp, r10
    mov rbp, rsp
    
  .end:  
  mov rbp,r15
  jmp qword [rax+TYPE_SIZE+WORD_BYTES] ;jmp code of closure
  ;add rsp , 8 ; pop the env
  ;pop r10 ; pop n
  ;shl r10 , 3 ; rbx = rbx * 8
  ;add rsp , r10 ;  pop args
  ; jmp .endApply 
.exit:
mov rdi, 0;return code 0
mov rax, 60 ; system call 60 is exit
syscall 
;.endApply:
;leave
;ret   


is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_vector:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_VECTOR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

vector_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    VECTOR_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

vector_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rax, [rsi]

    leave
    ret

vector_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rdi, PVAR(2)
    mov [rsi], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_vector:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    

    MAKE_VECTOR rax, rsi, rdi

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

.loop:
    cmp rcx, 0
    je .end
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    dec rcx
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov rax, qword [rsi + TYPE_SIZE]

    leave
    ret
    
cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov rax, qword [rsi + TYPE_SIZE + WORD_SIZE]

    leave
    ret
    
set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    mov rdi, PVAR(1) ;new car

    mov qword [rsi + TYPE_SIZE], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret
    
set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    mov rdi, PVAR(1) ;new cdr

    mov qword [rsi + TYPE_SIZE + WORD_SIZE], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret
    
cons:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    mov rdi, PVAR(1)
    MAKE_PAIR (rax, rsi, rdi) ;todo: check if need to be [rsi], [rdi]
    ;make_pair puts the result in rax
    leave
    ret